<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Screen configuration</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, rgba(59,130,246,0.25), transparent 55%), #020617;
      padding: clamp(1rem, 3vw, 2.5rem);
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .page__header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 1rem;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 4vw, 2.6rem);
      letter-spacing: 0.02em;
    }
    p {
      margin: 0.35rem 0 0;
      color: #94a3b8;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #22d3ee, #6366f1);
      color: #020617;
      box-shadow: 0 10px 30px rgba(79, 70, 229, 0.4);
      transition: transform 120ms ease, opacity 120ms ease;
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }
    button:not(:disabled):active {
      transform: translateY(2px);
    }
    .status {
      min-height: 1.5rem;
      font-weight: 600;
      color: #94a3b8;
    }
    .status[data-tone="success"] { color: #86efac; }
    .status[data-tone="error"] { color: #fca5a5; }
    .status[data-tone="info"] { color: #93c5fd; }
    .config-panel {
      background: rgba(15, 23, 42, 0.75);
      border-radius: 20px;
      padding: 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      box-shadow: 0 25px 50px rgba(15, 23, 42, 0.45);
    }
    .config-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
    }
    .config-header h2 {
      margin: 0;
      font-size: 1.4rem;
    }
    .config-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .config-actions button.secondary {
      background: rgba(148, 163, 184, 0.12);
      color: #e2e8f0;
      box-shadow: none;
    }
    .config-error {
      border: 1px solid rgba(248,113,113,0.6);
      background: rgba(248,113,113,0.08);
      padding: 0.75rem 1rem;
      border-radius: 16px;
      color: #fecaca;
      font-weight: 600;
    }
    .config-table {
      display: grid;
      grid-template-columns: 40px minmax(160px, 1.5fr) minmax(160px, 1fr) minmax(160px, 1fr) minmax(240px, 1.5fr) minmax(150px, 0.9fr);
      gap: 0.75rem 1rem;
      align-items: center;
    }
    .config-table__header {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
    }
    .config-group-list {
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }
    .config-group {
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 18px;
      background: rgba(2, 6, 23, 0.65);
      padding: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .group-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 14px;
      padding: 0.6rem 0.8rem;
    }
    .group-name-input {
      flex: 1;
      min-width: 180px;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 1rem;
      outline: none;
    }
    .group-add-select {
      min-width: 160px;
      background: rgba(15, 23, 42, 0.8);
      color: inherit;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 999px;
      padding: 0.4rem 0.7rem;
      font-size: 0.85rem;
      outline: none;
    }
    .group-remove {
      padding: 0.45rem 1rem;
      font-size: 0.85rem;
    }
    .group-screens {
      min-height: 1.5rem;
    }
    .config-row {
      display: contents;
    }
    .config-cell {
      background: rgba(15, 23, 42, 0.6);
      border-radius: 12px;
      padding: 0.65rem 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.15);
    }
    .config-cell input {
      width: 100%;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 0.95rem;
      outline: none;
    }
    .frequency-header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .hide-zero-toggle {
      font-size: 0.7rem;
      color: #cbd5f5;
      text-transform: none;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }
    .hide-zero-toggle input {
      accent-color: #38bdf8;
    }
    .alt-screen-selector {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .alt-screen-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }
    .alt-screen-tag {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.5rem 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.2);
      font-size: 0.8rem;
    }
    .alt-screen-tag button {
      border: none;
      background: transparent;
      color: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0;
    }
    .alt-screen-select {
      width: 100%;
      background: rgba(15, 23, 42, 0.8);
      color: inherit;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 10px;
      padding: 0.45rem 0.6rem;
      font-size: 0.9rem;
      outline: none;
    }
    .drag-handle {
      cursor: grab;
      font-size: 1.2rem;
      text-align: center;
      user-select: none;
    }
    .dragging-group {
      opacity: 0.6;
    }
    .dragging .config-cell {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <main class="page">
    <header class="page__header">
      <div>
        <h1>Screen configuration</h1>
        <p>Organize screens into playlist groups and adjust frequencies for the active playlist.</p>
      </div>
    </header>
    <section class="config-panel" aria-label="Screen configuration">
      <div class="config-header">
        <div>
          <h2>Playlist editor</h2>
          <p>Drag to reorder groups and screens, set frequencies, and add alternate screens.</p>
        </div>
        <div class="config-actions">
          <button type="button" class="config-save" disabled>Save changes</button>
          <button type="button" class="secondary config-add-group">Add group</button>
          <button type="button" class="secondary config-defaults">Load defaults</button>
          <button type="button" class="secondary config-export">Export configuration</button>
        </div>
      </div>
      <div class="status" id="config-status" aria-live="polite"></div>
      <div class="config-error" id="config-error" hidden></div>
      <div class="config-table config-table__header" aria-hidden="true">
        <div>Drag</div>
        <div>Screen</div>
        <div class="frequency-header">
          <div>Frequency</div>
          <label class="hide-zero-toggle" for="hide-zero-toggle">
            <input type="checkbox" id="hide-zero-toggle">
            Hide 0
          </label>
        </div>
        <div>Background color</div>
        <div>Alternate screens</div>
        <div>Alternate frequency</div>
      </div>
      <div class="config-group-list" id="config-list"></div>
      <div class="config-actions">
        <button type="button" class="config-save" disabled>Save changes</button>
        <button type="button" class="secondary config-add-group">Add group</button>
        <button type="button" class="secondary config-defaults">Load defaults</button>
        <button type="button" class="secondary config-export">Export configuration</button>
      </div>
    </section>
  </main>
  <script>
    (() => {
      const configList = document.getElementById('config-list');
      const configStatus = document.getElementById('config-status');
      const configError = document.getElementById('config-error');
      const configSaveButtons = Array.from(document.querySelectorAll('.config-save'));
      const configAddGroupButtons = Array.from(document.querySelectorAll('.config-add-group'));
      const configDefaultsButtons = Array.from(document.querySelectorAll('.config-defaults'));
      const configExportButtons = Array.from(document.querySelectorAll('.config-export'));
      const hideZeroToggle = document.getElementById('hide-zero-toggle');
      let configDirty = false;
      let availableScreenIds = [];
      let groupCounter = 0;

      function setConfigStatus(message, tone = 'info') {
        configStatus.textContent = message;
        configStatus.dataset.tone = tone;
      }

      function setConfigError(message = '') {
        if (!message) {
          configError.hidden = true;
          configError.textContent = '';
          return;
        }
        configError.hidden = false;
        configError.textContent = message;
      }

      function markConfigDirty(isDirty) {
        configDirty = isDirty;
        configSaveButtons.forEach((button) => {
          button.disabled = !configDirty;
        });
      }

      function parseAltScreens(value) {
        if (!value) {
          return [];
        }
        return value
          .split(',')
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function updateAltScreenValue(hiddenInput, values) {
        hiddenInput.value = values.join(', ');
        markConfigDirty(true);
      }

      function renderAltSelector(cell, screenId, currentValue) {
        cell.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'alt-screen-selector';

        const tags = document.createElement('div');
        tags.className = 'alt-screen-tags';

        const hiddenInput = document.createElement('input');
        hiddenInput.type = 'hidden';
        hiddenInput.className = 'alt-screen-input';
        hiddenInput.value = currentValue ?? '';

        const select = document.createElement('select');
        select.className = 'alt-screen-select';
        select.innerHTML = '<option value="">Add alternate…</option>';
        availableScreenIds
          .filter((id) => id !== screenId)
          .forEach((id) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = id;
            select.appendChild(option);
          });

        const renderTags = () => {
          tags.innerHTML = '';
          const values = parseAltScreens(hiddenInput.value);
          if (!values.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '0.8rem';
            empty.style.color = '#94a3b8';
            empty.textContent = 'No alternates selected';
            tags.appendChild(empty);
            return;
          }
          values.forEach((value) => {
            const tag = document.createElement('span');
            tag.className = 'alt-screen-tag';
            tag.textContent = value;
            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.setAttribute('aria-label', `Remove ${value}`);
            removeButton.textContent = '×';
            removeButton.addEventListener('click', () => {
              const updated = parseAltScreens(hiddenInput.value).filter((entry) => entry !== value);
              updateAltScreenValue(hiddenInput, updated);
              renderTags();
            });
            tag.appendChild(removeButton);
            tags.appendChild(tag);
          });
        };

        select.addEventListener('change', () => {
          const value = select.value;
          if (!value) {
            return;
          }
          const existing = parseAltScreens(hiddenInput.value);
          if (!existing.includes(value)) {
            updateAltScreenValue(hiddenInput, [...existing, value]);
            renderTags();
          }
          select.value = '';
        });

        wrapper.append(tags, select, hiddenInput);
        cell.appendChild(wrapper);
        renderTags();
      }

      function applyHideZero() {
        const hideZeros = hideZeroToggle.checked;
        configList.querySelectorAll('.freq-input').forEach((input) => {
          const value = input.value.trim();
          if (hideZeros && value === '0') {
            input.dataset.zeroHidden = 'true';
            input.value = '';
          } else if (!hideZeros && input.dataset.zeroHidden === 'true' && value === '') {
            input.value = '0';
            delete input.dataset.zeroHidden;
          }
        });
      }

      function nextGroupName() {
        groupCounter += 1;
        return `Group ${groupCounter}`;
      }

      function getUsedScreenIds() {
        return new Set(
          Array.from(configList.querySelectorAll('.config-row')).map((row) => row.dataset.screenId)
        );
      }

      function refreshAddScreenOptions() {
        const used = getUsedScreenIds();
        const available = availableScreenIds.filter((id) => !used.has(id));
        configList.querySelectorAll('.group-add-select').forEach((select) => {
          select.innerHTML = '<option value="">Add screen…</option>';
          available.forEach((id) => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = id;
            select.appendChild(option);
          });
        });
      }

      function buildScreenRow(screen) {
        const row = document.createElement('div');
        row.className = 'config-row';
        row.dataset.screenId = screen.id;
        row.draggable = true;

        row.innerHTML = `
          <div class="config-cell drag-handle" title="Drag to reorder" aria-label="Drag handle">⠿</div>
          <div class="config-cell">${screen.id}</div>
          <div class="config-cell">
            <input type="number" min="0" inputmode="numeric" class="freq-input" value="${screen.frequency ?? ''}">
          </div>
          <div class="config-cell">
            <input type="text" class="background-input" placeholder="#000000" value="${screen.background ?? ''}">
          </div>
          <div class="config-cell alt-screen-cell"></div>
          <div class="config-cell">
            <input type="number" min="0" inputmode="numeric" class="alt-frequency-input" placeholder="Optional" value="${screen.alt_frequency ?? ''}">
          </div>
        `;

        const altCell = row.querySelector('.alt-screen-cell');
        renderAltSelector(altCell, screen.id, screen.alt_screen ?? '');

        row.querySelectorAll('input').forEach((input) => {
          input.addEventListener('input', () => {
            if (input.classList.contains('freq-input') && input.dataset.zeroHidden === 'true') {
              delete input.dataset.zeroHidden;
            }
            markConfigDirty(true);
          });
        });

        row.addEventListener('dragstart', (event) => {
          const handle = event.target.closest('.drag-handle');
          if (!handle) {
            event.preventDefault();
            return;
          }
          row.classList.add('dragging');
          event.dataTransfer.effectAllowed = 'move';
        });

        row.addEventListener('dragend', () => {
          row.classList.remove('dragging');
          markConfigDirty(true);
          refreshAddScreenOptions();
        });

        return row;
      }

      function getDragAfterElement(container, y) {
        const draggableElements = Array.from(container.querySelectorAll('.config-row:not(.dragging)'));
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
          }
          return closest;
        }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
      }

      function getGroupAfterElement(container, y) {
        const draggableElements = Array.from(container.querySelectorAll('.config-group:not(.dragging-group)'));
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
          }
          return closest;
        }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
      }

      function buildGroup(group, groupIndex) {
        const groupElement = document.createElement('div');
        groupElement.className = 'config-group';
        groupElement.dataset.groupId = `group-${groupIndex}`;
        groupElement.draggable = true;

        groupElement.innerHTML = `
          <div class="group-header">
            <div class="drag-handle group-drag-handle" title="Drag group" aria-label="Drag group">⠿</div>
            <input type="text" class="group-name-input" value="${group.name}" placeholder="Group name">
            <select class="group-add-select"></select>
            <button type="button" class="secondary group-remove">Remove group</button>
          </div>
          <div class="config-table group-screens"></div>
        `;

        const groupNameInput = groupElement.querySelector('.group-name-input');
        groupNameInput.addEventListener('input', () => {
          markConfigDirty(true);
        });

        const addSelect = groupElement.querySelector('.group-add-select');
        addSelect.addEventListener('change', () => {
          const value = addSelect.value;
          if (!value) {
            return;
          }
          const screenRow = buildScreenRow({
            id: value,
            frequency: '',
            alt_screen: '',
            alt_frequency: '',
            background: '',
          });
          groupElement.querySelector('.group-screens').appendChild(screenRow);
          addSelect.value = '';
          markConfigDirty(true);
          applyHideZero();
          refreshAddScreenOptions();
        });

        const removeButton = groupElement.querySelector('.group-remove');
        removeButton.addEventListener('click', () => {
          groupElement.remove();
          markConfigDirty(true);
          refreshAddScreenOptions();
        });

        const screensContainer = groupElement.querySelector('.group-screens');
        (group.screens || []).forEach((screen) => {
          screensContainer.appendChild(buildScreenRow(screen));
        });

        groupElement.addEventListener('dragstart', (event) => {
          const handle = event.target.closest('.group-drag-handle');
          if (!handle) {
            event.preventDefault();
            return;
          }
          groupElement.classList.add('dragging-group');
          event.dataTransfer.effectAllowed = 'move';
        });

        groupElement.addEventListener('dragend', () => {
          groupElement.classList.remove('dragging-group');
          markConfigDirty(true);
        });

        screensContainer.addEventListener('dragover', (event) => {
          event.preventDefault();
          const afterElement = getDragAfterElement(screensContainer, event.clientY);
          const dragging = configList.querySelector('.dragging');
          if (!dragging) {
            return;
          }
          if (afterElement == null) {
            screensContainer.appendChild(dragging);
          } else {
            screensContainer.insertBefore(dragging, afterElement);
          }
        });

        return groupElement;
      }

      function renderConfigGroups(groups) {
        configList.innerHTML = '';
        groupCounter = 0;
        const safeGroups = groups && groups.length ? groups : [{ name: 'Playlist', screens: [] }];
        safeGroups.forEach((group) => {
          groupCounter += 1;
          const groupElement = buildGroup(
            { ...group, name: group.name || `Group ${groupCounter}` },
            groupCounter
          );
          configList.appendChild(groupElement);
        });
        applyHideZero();
        refreshAddScreenOptions();
      }

      configList.addEventListener('dragover', (event) => {
        event.preventDefault();
        const draggingGroup = configList.querySelector('.dragging-group');
        if (!draggingGroup) {
          return;
        }
        const afterElement = getGroupAfterElement(configList, event.clientY);
        if (afterElement == null) {
          configList.appendChild(draggingGroup);
        } else {
          configList.insertBefore(draggingGroup, afterElement);
        }
      });

      function buildConfigPayload() {
        return {
          groups: Array.from(configList.querySelectorAll('.config-group')).map((group) => ({
            name: group.querySelector('.group-name-input').value.trim() || 'Playlist',
            screens: Array.from(group.querySelectorAll('.config-row')).map((row) => ({
              id: row.dataset.screenId,
              frequency: row.querySelector('.freq-input').value,
              alt_screen: row.querySelector('.alt-screen-input').value,
              alt_frequency: row.querySelector('.alt-frequency-input').value,
              background: row.querySelector('.background-input').value,
            })),
          })),
        };
      }

      async function loadConfig(url) {
        setConfigError('');
        setConfigStatus('Loading screen configuration…', 'info');
        const resp = await fetch(url);
        const payload = await resp.json();
        if (!resp.ok || payload.status !== 'ok') {
          throw new Error(payload.message || 'Unable to load configuration');
        }
        availableScreenIds = payload.screen_ids || [];
        renderConfigGroups(payload.groups || []);
        markConfigDirty(false);
        setConfigStatus('Configuration loaded.', 'success');
      }

      async function saveConfig() {
        setConfigError('');
        setConfigStatus('Saving screen configuration…', 'info');
        const resp = await fetch('/api/screens', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(buildConfigPayload()),
        });
        const payload = await resp.json();
        if (!resp.ok || payload.status !== 'ok') {
          throw new Error(payload.message || 'Unable to save configuration');
        }
        markConfigDirty(false);
        setConfigStatus('Configuration saved to device override.', 'success');
      }

      configSaveButtons.forEach((button) => {
        button.addEventListener('click', async () => {
          button.disabled = true;
          try {
            await saveConfig();
          } catch (err) {
            setConfigError(err.message);
            setConfigStatus('Save failed.', 'error');
            markConfigDirty(true);
          } finally {
            button.disabled = !configDirty;
          }
        });
      });

      configAddGroupButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const groupElement = buildGroup({ name: nextGroupName(), screens: [] }, groupCounter);
          configList.appendChild(groupElement);
          markConfigDirty(true);
          refreshAddScreenOptions();
        });
      });

      configDefaultsButtons.forEach((button) => {
        button.addEventListener('click', async () => {
          try {
            await loadConfig('/api/screens/defaults');
          } catch (err) {
            setConfigError(err.message);
            setConfigStatus('Unable to load defaults.', 'error');
          }
        });
      });

      configExportButtons.forEach((button) => {
        button.addEventListener('click', () => {
          window.location.href = '/api/screens/export';
        });
      });

      hideZeroToggle.addEventListener('change', () => {
        applyHideZero();
      });

      loadConfig('/api/screens').catch((err) => {
        setConfigError(err.message);
        setConfigStatus('Unable to load configuration.', 'error');
      });
    })();
  </script>
</body>
</html>
